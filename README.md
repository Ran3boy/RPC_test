# Сравнительный анализ производительности REST, gRPC (RPC) и GraphQL на основе экспериментальных исследований и бенчмарков

В данном разделе приведён обзор экспериментальных работ, в которых выполняется количественное сравнение REST, GraphQL и RPC/gRPC. Рассматриваются исследования, содержащие измерения производительности (латентность, throughput, загрузка CPU) либо чётко описанные экспериментальные метрики, а также сформулированные авторами выводы.

## 1. REST vs GraphQL (производительность и латентность)

### Vadlamani et al. (SERIP 2021) — GitHub REST vs GitHub GraphQL API
Авторы сравнивали время ответа на парных запросах к публичным API GitHub, реализованных через REST и эквивалентные GraphQL-запросы. Для каждого запроса выполнялось по 50 повторений, а результаты анализировались с использованием статистических методов (t-test).

**Ключевой вывод:**
Отсутствует универсальный победитель. В зависимости от структуры запроса GraphQL может быть быстрее или медленнее REST, а в ряде случаев различия статистически незначимы.

**Примеры средних времен ответа (мс):**
*   **Query1:** REST ≈ 171, GraphQL ≈ 177
*   **Query3:** REST ≈ 225, GraphQL ≈ 145 (GraphQL быстрее)
*   **Query4:** REST ≈ 338, GraphQL ≈ 388 (REST быстрее)

### Jin et al. (University of Washington) — GraphQL vs REST for serverless data persistence
В работе сравниваются реализации GraphQL (AWS AppSync, Apollo Server) и REST (API Gateway + AWS Lambda) при доступе к PostgreSQL (Amazon Aurora). Метрики включали RTT и throughput при различных условиях сети и уровнях конкурентной нагрузки.

**Ключевой вывод:**
Apollo Server демонстрировал на 25–67% меньшее среднее RTT по сравнению с REST для большинства операций. Однако при экстремально высокой конкурентной нагрузке масштабируемость GraphQL-решений оказывалась хуже, чем у REST.

## 2. REST vs GraphQL vs gRPC (единый эксперимент)

### Niswar et al. (2024) — REST vs GraphQL vs gRPC в микросервисной архитектуре
Эксперимент включал несколько микросервисов в контейнерах с использованием Redis и MySQL. Сравнение выполнялось по времени ответа и загрузке CPU в двух сценариях:
1.  Работа с плоскими структурами данных.
2.  Работа с вложенными структурами данных.

Нагрузка составляла от 100 до 500 запросов.

**Ключевой вывод:**
*   **gRPC** показал наименьшее время ответа.
*   **REST** занял промежуточную позицию.
*   **GraphQL** оказался самым медленным и продемонстрировал более высокую загрузку CPU по сравнению с REST и gRPC.

## 3. REST vs gRPC (RPC): практические замеры

### Bolanowski et al. (SOMET 2022) — Efficiency of REST and gRPC
Экспериментальное исследование на платформе .NET, в котором рассматривались различные классы коммуникационных задач. Оценка выполнялась по времени ответа и условиям выполнения запросов (характер нагрузки, тип передаваемых данных, частота вызовов).

**Ключевой вывод:**
Авторы показали, что эффективность REST и gRPC существенно зависит от класса коммуникационных задач. gRPC оказывается более эффективным для сценариев с высокой частотой вызовов, малыми и средними payload и строгими требованиями к задержкам. REST, в свою очередь, демонстрирует приемлемые показатели в более простых сценариях и обладает преимуществами с точки зрения универсальности и совместимости. Существенной ценностью работы является формирование практических рекомендаций по выбору технологии в зависимости от характера нагрузки, а не попытка определить «абсолютно лучший» подход.

### gRPC Mobile Benchmarks (grpc.io, 2016) — gRPC / Protocol Buffers vs HTTP / JSON
Официальные бенчмарки, опубликованные разработчиками gRPC, посвящены сравнению бинарной сериализации Protocol Buffers и текстового формата JSON, а также сравнению gRPC unary-вызовов и RESTful HTTP-запросов в мобильной среде.

В рамках экспериментов измерялись следующие показатели:
*   Время сериализации и десериализации данных.
*   Размер передаваемых сообщений.
*   End-to-end latency.
*   Количество сетевых пакетов.

**Ключевой вывод:**
Protocol Buffers обеспечивает меньший размер сообщений и более высокую скорость сериализации по сравнению с JSON, а gRPC демонстрирует меньшую сквозную латентность за счёт использования HTTP/2 и бинарного протокола. Эти результаты часто используются как базовое обоснование выбора gRPC в распределённых системах и микросервисных архитектурах, особенно в условиях ограниченных сетевых ресурсов.

---

## Обобщённые выводы по результатам анализа исследований

На основе рассмотренных экспериментальных работ можно сформулировать следующие обобщённые выводы:

1.  **GraphQL vs REST.** GraphQL часто демонстрирует лучшие показатели в сценариях, где REST приводит к *over-fetching* или *under-fetching* данных. Однако на отдельных запросах GraphQL может уступать REST по латентности, а при экстремально высокой конкурентной нагрузке — по масштабируемости.
2.  **gRPC vs REST / GraphQL.** В большинстве прикладных экспериментов gRPC показывает наименьшее время ответа, что объясняется использованием бинарной сериализации Protocol Buffers и протокола HTTP/2.
3.  **Использование ресурсов.** GraphQL, как правило, характеризуется более высокой загрузкой CPU по сравнению с REST и gRPC, что необходимо учитывать при проектировании высоконагруженных систем.
4.  **Отсутствие универсального решения.** Ни один из подходов не является универсальным. Выбор технологии должен определяться структурой данных (плоские или вложенные), размером payload, уровнем конкурентной нагрузки, требованиями к строгой типизации контрактов и необходимостью поддержки браузерных клиентов.

---

## Связь с практической частью выпускной квалификационной работы

Результаты рассмотренных исследований подтверждают целесообразность применения RPC-подхода и gRPC во внутреннем взаимодействии микросервисов в рамках практической части выпускной квалификационной работы. Использование gRPC позволяет снизить латентность взаимодействия сервисов и обеспечить строгую формализацию контрактов API, что соответствует современным рекомендациям в области проектирования распределённых систем.
